from xmlrpc.client import Serverimport socketimport pickleimport cv2import timeimport numpy as npfrom PyQt5.QtWidgets import QWidget, QApplication, QLabel, QVBoxLayoutimport sysimport cv2from math import *import threadingimport configfrom interfacing import VideoThread, Appimport struct# Sonar constants needed for plotting visualizationMAX_RANGE = 80*200*1450/2LENGTH = 640CENTER = (LENGTH/2,LENGTH/2)image = np.zeros((LENGTH, LENGTH, 1), np.uint8)def TcpCom ():    # Define connection parameters of ROV RPi    SERVER = "169.254.226.72"    PORT = 1422    HEADERSIZE = 10        full_msg = b''    new_msg = True        # Using socket library, initialize a communication object    # and initialize TCP connection.    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((SERVER, PORT))        print(f"[NEW CONNECTION] With {SERVER} established")        while True:        # Receives TCP packets and stores in variable        msg = s.recv(8192) # 8192                # If the start of a data message is sent, find length of expected information        if new_msg:            msglen = int(msg[:HEADERSIZE])            new_msg = False                # Sum all packets to a full message        full_msg += msg                # If length of message is as previously decided, unpack data and call functions        if len(full_msg)-HEADERSIZE == msglen:            raspDataIn = pickle.loads(full_msg[HEADERSIZE:])            """            # Data of RovRPI is stored in raspDataIn            # Data will be relayed to Thingsboard            # Integrate Thingsboard transmission here.            # Data of RovRPI is stored in raspDataIn            # Data will be relayed to Thingsboard            # Integrate Thingsboard transmission here.            """            a.setDisplayValues(raspDataIn["temp"], raspDataIn["depth"], raspDataIn["leak"],            raspDataIn["lockedZones"], raspDataIn["salinity"], raspDataIn["conductivity"],            raspDataIn["density"])            plotSonarInput(RaspDataIn["angle"], raspDataIn["step"], raspDataIn["dataArray"])                            # Resets for next message            new_msg = True            full_msg = b""            # If TCP packet was not succesfully unpacked last message        # reset the input buffer        if len(full_msg) > 2500:                new_msg = True            full_msg = b""        def UDPCom():    # Datagram set to maximum allowable size    MAX_DGRAM = 2**16    dat = b''        """    Function that dumps the UDP buffer.    """    def dump_buffer(s):        while True:            seg, addr = s.recvfrom(MAX_DGRAM)            print(seg[0])            if struct.unpack('B', seg[0:1])[0] == 1:                print("UDP input buffer emptied")            break        # Using socket library, initialize a communication object    # and initialize UDP connection.    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)    s.bind(('169.254.226.73', 20001))        # Dumps buffer, so that completely new data will be read at this point     dump_buffer(s)        # Continuously checking for UDP datagrams and unpacks if an entire message    # has been received, else summing up datagrams until this is true    while 1:                seg, _ = s.recvfrom(MAX_DGRAM)        if struct.unpack("B", seg[0:1])[0] > 1:            dat += seg[1:]        else:            dat += seg[1:]            img = cv2.imdecode(np.frombuffer(dat, dtype=np.uint8), 1)            try:                config.rovCamera = img            except:                print("error (-215:Assertion failed)")            if cv2.waitKey(20) & 0xFF == ord('q'):                break            """            # Relay information further here            # To next AIP RPi            # Relay information further here            # To next AIP RPi            # Relay information further here            # To next AIP RPi            """            dat = b''    s.close()# Mainif __name__=="__main__":    # Opening an UDP server in GUI application    cam_communication = threading.Thread(target=UDPCom)    cam_communication.start()    # Opening a TCP client in GUI application    other_communication = threading.Thread(target=TCPCom)    other_communication.start()