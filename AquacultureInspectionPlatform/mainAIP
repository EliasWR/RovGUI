from xmlrpc.client import Serverimport socketimport pickleimport cv2import timeimport numpy as npfrom PyQt5.QtWidgets import QWidget, QApplication, QLabel, QVBoxLayoutimport sysimport cv2from math import *import threadingimport configfrom interfacing import VideoThread, Appimport struct# Sonar constants needed for plotting visualizationMAX_RANGE = 80*200*1450/2LENGTH = 640CENTER = (LENGTH/2,LENGTH/2)image = np.zeros((LENGTH, LENGTH, 1), np.uint8)def TcpCom ():    # Define connection parameters of ROV RPi    SERVER = "169.254.226.72"    PORT = 1422    HEADERSIZE = 10        full_msg = b''    new_msg = True        # Using socket library, initialize a communication object    # and initialize TCP connection.    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((SERVER, PORT))        print(f"[NEW CONNECTION] With {SERVER} established")        while True:        # Receives TCP packets and stores in variable        msg = s.recv(8192) # 8192                # If the start of a data message is sent, find length of expected information        if new_msg:            msglen = int(msg[:HEADERSIZE])            new_msg = False                # Sum all packets to a full message        full_msg += msg                # If length of message is as previously decided, unpack data and call functions        if len(full_msg)-HEADERSIZE == msglen:            raspDataIn = pickle.loads(full_msg[HEADERSIZE:])                        # Data of RovRPI is stored in raspDataIn            # Data will be relayed to Thingsboard            # Integrate Thingsboard transmission here.                        a.setDisplayValues(raspDataIn["temp"], raspDataIn["depth"], raspDataIn["leak"],            raspDataIn["lockedZones"], raspDataIn["salinity"], raspDataIn["conductivity"],            raspDataIn["density"])            plotSonarInput(RaspDataIn["angle"], raspDataIn["step"], raspDataIn["dataArray"])                            # Resets for next message            new_msg = True            full_msg = b""            # If TCP packet was not succesfully unpacked last message        # reset the input buffer        if len(full_msg) > 2500:                new_msg = True            full_msg = b""                